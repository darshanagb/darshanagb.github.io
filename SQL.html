<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Window Frames: PRECEDING, FOLLOWING, and More</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 40px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        h3 {
            color: #7f8c8d;
            margin-top: 20px;
        }
        code {
            background-color: #ecf0f1;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 13px;
        }
        .concept-box {
            background-color: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
            border-radius: 3px;
        }
        .example-box {
            background-color: #fef9e7;
            border-left: 4px solid #f39c12;
            padding: 15px;
            margin: 20px 0;
            border-radius: 3px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: white;
        }
        th, td {
            border: 1px solid #bdc3c7;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .frame-diagram {
            background-color: white;
            border: 1px solid #bdc3c7;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            text-align: center;
            font-family: monospace;
            line-height: 1.8;
        }
        .note {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 3px;
        }
        .highlight {
            background-color: #fff9e6;
            padding: 2px 4px;
        }
        .print-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-bottom: 30px;
        }
        .print-button:hover {
            background-color: #2980b9;
        }
        @media print {
            * {
                margin: 0 !important;
                padding: 0 !important;
                background: white !important;
            }
            body {
                background-color: white;
                padding: 20px !important;
            }
            .print-button {
                display: none;
            }
            .concept-box, .example-box, .note {
                page-break-inside: avoid;
            }
            h1, h2, h3 {
                page-break-after: avoid;
            }
        }
    </style>
</head>
<body>

<h1>SQL Window Frames: PRECEDING, FOLLOWING, and More</h1>

<button class="print-button" onclick="window.print()">üñ®Ô∏è Print to PDF</button>

<div class="concept-box">
    <strong>Overview:</strong> Window frame specifications define which rows are included in a window function's calculation relative to the current row. They're used with the ROWS or RANGE clause in window functions.
</div>

<h2>1. What is a Window Frame?</h2>

<p>A window frame specifies the set of rows within a window partition that a window function operates on. For each row, the frame defines a range of rows to include in calculations.</p>

<p><strong>Basic Syntax:</strong></p>
<pre>SELECT column_name,
    FUNCTION_NAME(column) OVER (
        PARTITION BY partition_column
        ORDER BY sort_column
        ROWS BETWEEN frame_start AND frame_end
    )
FROM table_name;</pre>

<h2>2. Frame Boundaries</h2>

<h3>UNBOUNDED PRECEDING</h3>
<div class="concept-box">
    Includes all rows from the beginning of the partition up to the current row.
</div>
<div class="frame-diagram">
    [START] ... (current row)<br>
    ‚Üë UNBOUNDED PRECEDING ‚Üë
</div>

<h3>PRECEDING</h3>
<div class="concept-box">
    Includes a specific number of rows <span class="highlight">before</span> the current row. Syntax: <code>n PRECEDING</code> where n is an integer.
</div>
<div class="frame-diagram">
    Row n-2 | Row n-1 | (current row)<br>
    ‚Üê 2 PRECEDING ‚Üí | CURRENT
</div>

<h3>CURRENT ROW</h3>
<div class="concept-box">
    Includes only the current row in the frame.
</div>
<div class="frame-diagram">
    ... | (current row) | ...<br>
    &nbsp;&nbsp;&nbsp;&nbsp;CURRENT ROW
</div>

<h3>FOLLOWING</h3>
<div class="concept-box">
    Includes a specific number of rows <span class="highlight">after</span> the current row. Syntax: <code>n FOLLOWING</code> where n is an integer.
</div>
<div class="frame-diagram">
    (current row) | Row n+1 | Row n+2<br>
    CURRENT &nbsp; | ‚Üê 2 FOLLOWING ‚Üí
</div>

<h3>UNBOUNDED FOLLOWING</h3>
<div class="concept-box">
    Includes all rows from the current row to the end of the partition.
</div>
<div class="frame-diagram">
    (current row) ... [END]<br>
    ‚Üì UNBOUNDED FOLLOWING ‚Üì
</div>

<h2>3. Common Frame Combinations</h2>

<table>
    <tr>
        <th>Frame Specification</th>
        <th>Includes</th>
        <th>Use Case</th>
    </tr>
    <tr>
        <td><code>UNBOUNDED PRECEDING AND CURRENT ROW</code></td>
        <td>All rows from partition start to current row</td>
        <td>Running total, cumulative sum</td>
    </tr>
    <tr>
        <td><code>CURRENT ROW AND UNBOUNDED FOLLOWING</code></td>
        <td>Current row through partition end</td>
        <td>Running balance backwards</td>
    </tr>
    <tr>
        <td><code>1 PRECEDING AND 1 FOLLOWING</code></td>
        <td>1 row before, current row, 1 row after</td>
        <td>Moving average of 3 rows</td>
    </tr>
    <tr>
        <td><code>UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</code></td>
        <td>All rows in partition</td>
        <td>Partition-level calculations</td>
    </tr>
</table>

<h2>4. Practical Examples</h2>

<h3>Example 1: Running Total (Cumulative Sum)</h3>
<div class="example-box">
    <strong>Scenario:</strong> Calculate cumulative sales for each employee ordered by date.
</div>
<pre>SELECT 
    employee_id,
    sale_date,
    amount,
    SUM(amount) OVER (
        PARTITION BY employee_id 
        ORDER BY sale_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_sales
FROM sales
ORDER BY employee_id, sale_date;</pre>

<p><strong>Result Structure:</strong></p>
<table>
    <tr>
        <th>Employee</th>
        <th>Date</th>
        <th>Amount</th>
        <th>Cumulative</th>
    </tr>
    <tr>
        <td>1</td>
        <td>2024-01-01</td>
        <td>100</td>
        <td>100</td>
    </tr>
    <tr>
        <td>1</td>
        <td>2024-01-05</td>
        <td>150</td>
        <td>250</td>
    </tr>
    <tr>
        <td>1</td>
        <td>2024-01-10</td>
        <td>200</td>
        <td>450</td>
    </tr>
</table>

<h3>Example 2: Moving Average</h3>
<div class="example-box">
    <strong>Scenario:</strong> Calculate a 3-row moving average of daily temperatures.
</div>
<pre>SELECT 
    date,
    temperature,
    AVG(temperature) OVER (
        ORDER BY date
        ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ) AS moving_avg_3day
FROM weather_data
ORDER BY date;</pre>

<p>For each row, this includes the previous day, current day, and next day in the average calculation.</p>

<h3>Example 3: Remaining Balance</h3>
<div class="example-box">
    <strong>Scenario:</strong> Calculate remaining balance from current month to end of year.
</div>
<pre>SELECT 
    month,
    revenue,
    SUM(revenue) OVER (
        ORDER BY month
        ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
    ) AS remaining_revenue
FROM monthly_revenue
WHERE year = 2024
ORDER BY month;</pre>

<h3>Example 4: Year-to-Date and Partition Total</h3>
<div class="example-box">
    <strong>Scenario:</strong> Compare year-to-date sales with yearly total.
</div>
<pre>SELECT 
    department,
    month,
    sales,
    SUM(sales) OVER (
        PARTITION BY department 
        ORDER BY month
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS ytd_sales,
    SUM(sales) OVER (
        PARTITION BY department
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS annual_total
FROM sales_data
ORDER BY department, month;</pre>

<h2>5. Real-World Examples with Sample Schemas</h2>

<h3>Sample Schema: Farmers Market</h3>
<pre>CREATE TABLE farmers_market.sales (
    sale_id INT,
    sale_date DATE,
    vendor_id INT,
    customer_id INT,
    product_id INT,
    quantity INT,
    sale_amount DECIMAL(10, 2)
);

CREATE TABLE farmers_market.vendors (
    vendor_id INT,
    vendor_name VARCHAR(100),
    vendor_type VARCHAR(50)
);</pre>

<h3>Sample Schema: Employees</h3>
<pre>CREATE TABLE company.employees (
    employee_id INT,
    employee_name VARCHAR(100),
    department VARCHAR(50),
    salary DECIMAL(10, 2),
    hire_date DATE,
    manager_id INT
);</pre>

<h3>Example Question 1: Running Total of Vendor Sales</h3>
<div class="example-box">
    <strong>Question:</strong> For each vendor, show their sales chronologically with a running total of sales amounts.
</div>
<pre>SELECT 
    v.vendor_name,
    s.sale_date,
    s.sale_amount,
    SUM(s.sale_amount) OVER (
        PARTITION BY s.vendor_id 
        ORDER BY s.sale_date, s.sale_id
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total_sales
FROM farmers_market.sales s
JOIN farmers_market.vendors v ON s.vendor_id = v.vendor_id
ORDER BY v.vendor_name, s.sale_date;</pre>

<p><strong>Explanation:</strong> UNBOUNDED PRECEDING AND CURRENT ROW creates a running total by including all sales from the beginning of each vendor's partition up to the current row. As you go down each vendor's data, the running total grows.</p>

<table>
    <tr>
        <th>Vendor Name</th>
        <th>Sale Date</th>
        <th>Amount</th>
        <th>Running Total</th>
    </tr>
    <tr>
        <td>Fresh Farms</td>
        <td>2024-01-06</td>
        <td>$42.50</td>
        <td>$42.50</td>
    </tr>
    <tr>
        <td>Fresh Farms</td>
        <td>2024-01-13</td>
        <td>$55.00</td>
        <td>$97.50</td>
    </tr>
    <tr>
        <td>Fresh Farms</td>
        <td>2024-01-20</td>
        <td>$38.75</td>
        <td>$136.25</td>
    </tr>
</table>

<h3>Example Question 2: Compare Salary to Department Average</h3>
<div class="example-box">
    <strong>Question:</strong> Show each employee's salary alongside the average salary within 1 salary level above and below theirs (by value, not rank).
</div>
<pre>SELECT 
    employee_name,
    department,
    salary,
    AVG(salary) OVER (
        PARTITION BY department 
        ORDER BY salary
        RANGE BETWEEN 5000 PRECEDING AND 5000 FOLLOWING
    ) AS nearby_avg_salary
FROM company.employees
ORDER BY department, salary;</pre>

<p><strong>Explanation:</strong> RANGE BETWEEN 5000 PRECEDING AND 5000 FOLLOWING includes all employees in the same department whose salary is within $5,000 (¬±) of the current employee's salary. This is different from ROWS, which would only look at 5 specific rows.</p>

<table>
    <tr>
        <th>Employee</th>
        <th>Dept</th>
        <th>Salary</th>
        <th>Nearby Avg</th>
    </tr>
    <tr>
        <td>Alice Johnson</td>
        <td>Engineering</td>
        <td>$95,000</td>
        <td>$94,667</td>
    </tr>
    <tr>
        <td>Bob Smith</td>
        <td>Engineering</td>
        <td>$98,000</td>
        <td>$97,000</td>
    </tr>
    <tr>
        <td>Carol White</td>
        <td>Engineering</td>
        <td>$99,500</td>
        <td>$97,750</td>
    </tr>
</table>

<h3>Example Question 3: 3-Row Moving Average of Sales</h3>
<div class="example-box">
    <strong>Question:</strong> Calculate a 3-day moving average of total daily sales at the farmers market (1 day before, current day, 1 day after).
</div>
<pre>SELECT 
    s.sale_date,
    SUM(s.sale_amount) AS daily_sales,
    AVG(SUM(s.sale_amount)) OVER (
        ORDER BY s.sale_date
        ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ) AS three_day_moving_avg
FROM farmers_market.sales s
GROUP BY s.sale_date
ORDER BY s.sale_date;</pre>

<p><strong>Explanation:</strong> ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING creates a window of 3 consecutive days for each date. This smooths out daily fluctuations to show trends more clearly.</p>

<table>
    <tr>
        <th>Date</th>
        <th>Daily Sales</th>
        <th>3-Day Moving Avg</th>
    </tr>
    <tr>
        <td>2024-01-06</td>
        <td>$450.00</td>
        <td>$491.67</td>
    </tr>
    <tr>
        <td>2024-01-13</td>
        <td>$580.00</td>
        <td>$550.00</td>
    </tr>
    <tr>
        <td>2024-01-20</td>
        <td>$510.00</td>
        <td>$513.33</td>
    </tr>
</table>

<h3>Example Question 4: Year-to-Date Sales vs Annual Total</h3>
<div class="example-box">
    <strong>Question:</strong> For each vendor, show their year-to-date sales (cumulative) and full year projection for 2024.
</div>
<pre>SELECT 
    v.vendor_name,
    EXTRACT(MONTH FROM s.sale_date) AS month,
    SUM(s.sale_amount) AS monthly_sales,
    SUM(SUM(s.sale_amount)) OVER (
        PARTITION BY s.vendor_id 
        ORDER BY EXTRACT(MONTH FROM s.sale_date)
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS ytd_sales,
    SUM(SUM(s.sale_amount)) OVER (
        PARTITION BY s.vendor_id
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS full_year_total
FROM farmers_market.sales s
JOIN farmers_market.vendors v ON s.vendor_id = v.vendor_id
WHERE EXTRACT(YEAR FROM s.sale_date) = 2024
GROUP BY v.vendor_id, v.vendor_name, EXTRACT(MONTH FROM s.sale_date)
ORDER BY v.vendor_name, month;</pre>

<p><strong>Explanation:</strong> This example uses two different frames:
<ul>
    <li><strong>UNBOUNDED PRECEDING AND CURRENT ROW:</strong> Calculates YTD (cumulative) sales</li>
    <li><strong>UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING:</strong> Looks at all rows in the vendor partition to get annual total</li>
</ul>
</p>

<table>
    <tr>
        <th>Vendor</th>
        <th>Month</th>
        <th>Sales</th>
        <th>YTD</th>
        <th>Annual Total</th>
    </tr>
    <tr>
        <td>Fresh Farms</td>
        <td>1</td>
        <td>$450</td>
        <td>$450</td>
        <td>$4,200</td>
    </tr>
    <tr>
        <td>Fresh Farms</td>
        <td>2</td>
        <td>$520</td>
        <td>$970</td>
        <td>$4,200</td>
    </tr>
    <tr>
        <td>Fresh Farms</td>
        <td>3</td>
        <td>$480</td>
        <td>$1,450</td>
        <td>$4,200</td>
    </tr>
</table>

<h3>Example Question 5: Employee Rank with Salary Comparison</h3>
<div class="example-box">
    <strong>Question:</strong> For each employee, show their salary compared to the previous and next employee's salary in their department (when sorted by salary).
</div>
<pre>SELECT 
    employee_name,
    department,
    salary,
    LAG(salary) OVER (
        PARTITION BY department 
        ORDER BY salary
    ) AS prev_emp_salary,
    LEAD(salary) OVER (
        PARTITION BY department 
        ORDER BY salary
    ) AS next_emp_salary,
    salary - LAG(salary) OVER (
        PARTITION BY department 
        ORDER BY salary
    ) AS salary_increase_from_prev
FROM company.employees
ORDER BY department, salary;</pre>

<p><strong>Explanation:</strong> LAG (1 PRECEDING) and LEAD (1 FOLLOWING) are shortcuts for accessing adjacent rows. This shows salary progression within each department without complex frame syntax.</p>

<table>
    <tr>
        <th>Employee</th>
        <th>Dept</th>
        <th>Salary</th>
        <th>Prev</th>
        <th>Next</th>
        <th>Increase</th>
    </tr>
    <tr>
        <td>Alice Johnson</td>
        <td>Engineering</td>
        <td>$95,000</td>
        <td>NULL</td>
        <td>$98,000</td>
        <td>NULL</td>
    </tr>
    <tr>
        <td>Bob Smith</td>
        <td>Engineering</td>
        <td>$98,000</td>
        <td>$95,000</td>
        <td>$99,500</td>
        <td>$3,000</td>
    </tr>
    <tr>
        <td>Carol White</td>
        <td>Engineering</td>
        <td>$99,500</td>
        <td>$98,000</td>
        <td>NULL</td>
        <td>$1,500</td>
    </tr>
</table>

<h2>6. ROWS vs RANGE Clause</h2>

<p><strong>ROWS:</strong> Counts a specific number of physical rows.</p>
<pre>ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
-- Includes exactly 2 rows before + current row</pre>

<p><strong>RANGE:</strong> Includes all rows with values within a specified range (useful for dealing with ties).</p>
<pre>RANGE BETWEEN 100 PRECEDING AND CURRENT ROW
-- Includes all rows where value is between (current_value - 100) and current_value</pre>

<h2>6. Default Frame Behavior</h2>

<div class="note">
    <strong>Important:</strong> When you use ORDER BY without specifying a frame, SQL defaults to <code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>. Without ORDER BY, the default is <code>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</code>.
</div>

<p>This means window functions like SUM and AVG automatically compute running totals when you include ORDER BY, unless you explicitly specify a different frame.</p>

<h2>7. Best Practices</h2>

<ul>
    <li><strong>Always specify the frame explicitly</strong> rather than relying on defaults for clarity</li>
    <li><strong>Use ROWS for physical row counts</strong> when the offset is a fixed number</li>
    <li><strong>Use RANGE for value-based ranges</strong> when dealing with time intervals or value ranges</li>
    <li><strong>Test edge cases</strong> like partition boundaries and NULL values</li>
    <li><strong>Consider performance</strong> with large datasets‚Äîwindow functions can be expensive</li>
    <li><strong>Be precise with ORDER BY</strong>‚Äîthe order dramatically affects which rows are included</li>
</ul>

<h2>8. Summary Table</h2>

<table>
    <tr>
        <th>Keyword</th>
        <th>Direction</th>
        <th>Scope</th>
    </tr>
    <tr>
        <td><code>UNBOUNDED PRECEDING</code></td>
        <td>Backward</td>
        <td>Start of partition to current row</td>
    </tr>
    <tr>
        <td><code>n PRECEDING</code></td>
        <td>Backward</td>
        <td>n rows before current row</td>
    </tr>
    <tr>
        <td><code>CURRENT ROW</code></td>
        <td>Neither</td>
        <td>Only current row</td>
    </tr>
    <tr>
        <td><code>n FOLLOWING</code></td>
        <td>Forward</td>
        <td>n rows after current row</td>
    </tr>
    <tr>
        <td><code>UNBOUNDED FOLLOWING</code></td>
        <td>Forward</td>
        <td>Current row to end of partition</td>
    </tr>
</table>

</body>
</html>